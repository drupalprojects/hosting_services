<?php

/**
 * @file
 * This is the main module file for Aegir SaaS.
 *
 * It provides Drupal hooks and functions for the module.
 *
 * @todo Convert platform handling to distribution handling once
 * https://www.drupal.org/node/2704799 gets implemented.
 */

/**
 * Define the role created by the module.
 */
const HOSTING_SAAS_ROLE = "aegir web services";

/**
 * Define the user created by the module.
 */
const HOSTING_SAAS_USER = "Aegir SaaS";

/**
 * Implementation of hook_menu().
 */
function hosting_saas_menu() {
  $items['admin/hosting/saas'] = array(
    'title' => 'SaaS',
    'description' => 'Configure software-as-a-service settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_saas_settings'),
    'access arguments' => array('administer modules'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * SaaS configuration form.
 */
function hosting_saas_settings() {
  $form['hosting_saas_master_domain'] = array(
    '#type' => 'textfield',
    '#title' => t('Master domain name'),
    '#description' => t('The master domain for your SaaS sites. Accepted URLs will be <em>*.thisfield</em>.'),
    '#default_value' => variable_get('hosting_saas_master_domain', 'localhost'),
    '#required' => TRUE,
  );

  $form['hosting_saas_template_site_nid'] = array(
    '#type' => 'textfield',
    '#title' => t('Template site node ID'),
    '#description' => t('The node ID of the site to clone on a new task clone request. This can either be set here, or provided in the remote request. If provided in the request, the value here will be overridden. Can be ignored if using an install-based method instead of the clone-based one provided by this module.'),
    '#default_value' => variable_get('hosting_saas_template_site_nid', ''),
  );

  $form['hosting_saas_db_server'] = array(
    '#type' => 'textfield',
    '#title' => t('Database server node ID'),
    '#description' => t('The node ID of the database server to use. This can either be set here, or provided in the remote request. If provided in the request, the value here will be overridden. Can be ignored if using an install-based method instead of the clone-based one provided by this module.'),
    '#default_value' => variable_get('hosting_saas_db_server', ''),
  );

  $form['hosting_saas_target_platform'] = array(
    '#type' => 'textfield',
    '#title' => t('Target platform node ID'),
    '#description' => t('The node ID of the platform on which to create the site. This can either be set here, or provided in the remote request. If provided in the request, the value here will be overridden. Can be ignored if using an install-based method instead of the clone-based one provided by this module.'),
    '#default_value' => variable_get('hosting_saas_target_platform', ''),
  );

  $form['hosting_saas_max_capacity'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of sites'),
    '#description' => t('The maximum number of SaaS sites allowed on the server. This will only count active sites. For an unlimited number of sites, leave this value at zero.'),
    '#default_value' => variable_get('hosting_saas_max_capacity', '0'),
  );

  return system_settings_form($form);
}

/**
 * Validation for SaaS configuration form.
 */
function hosting_saas_settings_validate($form, &$form_state) {

  // Ensure that the site clone ID is actually a site.
  if (!empty($form_state['values']['hosting_saas_template_site_nid'])) {
    $node = node_load($form_state['values']['hosting_saas_template_site_nid']);
    if ((!is_object($node)) || ($node->type != 'site')) {
      form_set_error('hosting_saas_template_site_nid', t('Must be a valid site.'));
    }
  }

  // Ensure that the DB server ID is actually a server.
  if (!empty($form_state['values']['hosting_saas_db_server'])) {
    $node = node_load($form_state['values']['hosting_saas_db_server']);
    if ((!is_object($node)) || ($node->type != 'server')) {
      form_set_error('hosting_saas_db_server', t('Must be a valid database server.'));
    }
  }

  // Ensure that the target platform ID is actually a platform.
  if (!empty($form_state['values']['hosting_saas_target_platform'])) {
    $node = node_load($form_state['values']['hosting_saas_target_platform']);
    if ((!is_object($node)) || ($node->type != 'platform')) {
      form_set_error('hosting_saas_target_platform', t('Must be a valid platform.'));
    }
  }

  // Ensure that the maximum number of sites is a non-negative integer.
  $number = $form_state['values']['hosting_saas_max_capacity'];
  if ((!ctype_digit($number)) || ($number < 0)) {
    form_set_error('hosting_saas_max_capacity', t('Must be a non-negative number.'));
  }
}

/**
 * Implements hook_services_request_preprocess_alter().
 *
 * Add missing configuration to site clone requests.
 */
function hosting_saas_services_request_preprocess_alter($controller, &$args, $options) {
  if (($GLOBALS['user']->name == HOSTING_SAAS_USER) &&
      ($options['resource'] == 'task') &&
      ($controller['callback'] == 'hosting_services_save_task') &&
      ($args[1] == 'clone')) {

    // Ensure that we have a URL for the new site.
    if (empty($args[2]['new_uri'])) {
      watchdog('hosting_saas', "Cannot populate site clone task: URL of the new site was not specified. It must be provided in the POST form data as 'options[new_uri]'.", array(), WATCHDOG_ERROR);
      return;
    }

    // Set unset arguments so that we may reference them.
    if (empty($args[2]['new_db_server'])) {
      $args[2]['new_db_server'] = '';
    }
    if (empty($args[2]['target_platform'])) {
      $args[2]['target_platform'] = '';
    }

    // Get references to all of the alterable or otherwise useful arguments.
    $cloned_node_nid = &$args[0];
    $new_uri = &$args[2]['new_uri'];
    $db_server_nid = &$args[2]['new_db_server'];
    $target_platform_nid = &$args[2]['target_platform'];

    // Ensure the new URL is valid.
    $domain = variable_get('hosting_saas_master_domain', 'localhost');
    if (!hosting_saas_url_matches_domain($new_uri, $domain)) {
      // The URL doesn't fit the configured domain.
      $cloned_node_nid = NULL;
      watchdog('hosting_saas', "Cannot populate site clone task: The requested URL '%url' does not match the configured domain '%domain'.", array(
        '%url' => $new_uri,
        '%domain' => $domain,
      ), WATCHDOG_ERROR);
      return;
    }

    // Set the ID of the site node to clone if it wasn't provided.
    if (empty($cloned_node_nid)) {
      if (empty($cloned_node_nid_saved = variable_get('hosting_saas_template_site_nid', ''))) {
        watchdog('hosting_saas', "Cannot populate site clone task: ID of site to clone was not specified. Either save it in the settings, or provide the site node ID as 'nid' in the POST form data.", array(), WATCHDOG_ERROR);
        return;
      }
      $cloned_node_nid = $cloned_node_nid_saved;
    }

    // Set the ID of the database server if it wasn't provided.
    if (empty($db_server_nid)) {
      if (empty($db_server_nid_saved = variable_get('hosting_saas_db_server', ''))) {
        watchdog('hosting_saas', "Cannot populate site clone task: Target DB server ID not specified. Either save it in the settings, or provide the server node ID as options[new_db_server] in the POST form data.", array(), WATCHDOG_ERROR);
        return;
      }
      $db_server_nid = $db_server_nid_saved;
    }

    // Set the ID of the platform if it wasn't provided.
    if (empty($target_platform_nid)) {
      if (empty($target_platform_nid_saved = variable_get('hosting_saas_target_platform', ''))) {
        watchdog('hosting_saas', "Cannot populate site clone task: Target platform ID not specified. Either save it in the settings, or provide the server node ID as options[target_platform] in the POST form data.", array(), WATCHDOG_ERROR);
        return;
      }
      $target_platform_nid = $target_platform_nid_saved;
    }

    // Ensure maximum capacity hasn't been reached.
    $capacity = variable_get('hosting_saas_max_capacity', '0');
    if (hosting_saas_at_full_capacity($target_platform_nid, $capacity) === TRUE) {
      // If it has, cause a failure and report it.
      $cloned_node_nid = NULL;
      watchdog('hosting_saas', "Cannot fulfill site clone task: The maximum number of sites have already been provisioned through this service.", array(), WATCHDOG_ALERT);
      return;
    }
  }
}

/**
 * Check to see if a given URL falls within a specific domain.
 *
 * @param $url
 *   The URL the check against the domain.
 * @param $domain
 *   The domain to compare with the URL.
 * @return
 *   TRUE if the URL is in the domain, FALSE otherwise.
 */
function hosting_saas_url_matches_domain($url, $domain) {
  // Prefix the URL with a dot.
  $dot_domain = '.' . $domain;

  // Get its length.
  $length = strlen($domain) + 1;

  // Compare it with the domain.
  if (substr_compare($url, $dot_domain, -$length, $length) === 0) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Check to see if we're at the maximum number of sites allowed.
 *
 * @param $platform
 *   The platform whose capacity is to be checked.
 * @param $capacity
 *   The total number of sites allowed on the system.
 * @return
 *   TRUE if we're at capacity, FALSE otherwise.
 */
function hosting_saas_at_full_capacity($platform, $capacity) {

  // If there's no limit, we can never be at capacity.
  if (intval($capacity) <= 0) {
    return FALSE;
  }

  // Fetch the number of sites on the platform.
  $count = hosting_site_count($platform);

  // If the number of sites has reached the limit, report a problem.
  if ($count >= $capacity) {
    return TRUE;
  }

  // Otherwise, everything is fine. Leave the flag down with log entry.
  watchdog('hosting_saas', 'Site count / capacity: %count / %capacity', array(
    '%count' => $count,
    '%capacity' => $capacity,
  ));
  return FALSE;
}

/**
 * Makes a site based on the settings.
 *
 * @param $url            The desired URL (FQDN)
 * @param $error_message  (Outgoing.) The error message that can be set on fail
 *
 * @return TRUE if successful, FALSE otherse. If this fails, the $error_message
 * will be set.
 */
function hosting_saas_clone_site_from_template($url, &$error_message = '') {
  $variables = array(
    'hosting_saas_target_platform',
    'hosting_saas_db_server',
    'hosting_saas_template_site_nid',
  );

  foreach ($variables as $to_check) {
    if (variable_get($to_check, NULL) === NULL) {
      watchdog('hosting_saas', "Variable hasn't been chosen yet: " . $to_check, array(), WATCHDOG_WARNING);

      $error_message = "Variable hasn't been chosen yet: " . $to_check;
      return FALSE;
    }
  }

  $model_site_nid = variable_get('hosting_saas_template_site_nid', NULL);

  if (!hosting_domain_allowed($url)) {
    $error_message = "This domain is not allowed. It is likely already being used.";
    return FALSE;
  }

  $args = array(
    'new_uri' => $url,
    'new_db_server' => variable_get('hosting_saas_db_server', NULL),
    'target_platform' => variable_get('hosting_saas_target_platform', NULL),
  );

  // Allow other modules to modify the options
  module_invoke_all('hosting_saas_clone', $url, $args);

  hosting_add_task($model_site_nid, 'clone', $args);

  return TRUE;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function hosting_saas_ctools_plugin_api($owner, $api) {
  // Ensure that we'll be able to register our Services endpoint.
  if (($owner == 'services') && ($api == 'services')) {
    return array(
      'version' => 3,
    );
  }
}

/**
 * Implements hook_default_services_endpoint().
 *
 * Register our Services endpoint.
 */
function hosting_saas_default_services_endpoint() {

  // This is the configuration for our endpoint. It differs from a UI export
  // in that we're generating a pseudo-random API key through a function call.
  $endpoint = new stdClass();
  $endpoint->disabled = FALSE; /* Edit this to true to make a default endpoint disabled initially */
  $endpoint->api_version = 3;
  $endpoint->name = 'hosting_saas';
  $endpoint->server = 'rest_server';
  $endpoint->path = 'aegir/saas';
  $endpoint->authentication = array(
    'services_api_key_auth' => array(
      // The API key being defined here will actually change every time the
      // configuration is loaded. This is a security feature to prevent a fixed
      // or empty one from being used for unauthorized remote access. To
      // generate a stable one that can be used for legitimate access
      // consistently, an administrator must manually save the authentication
      // form to override these default settings.
      'api_key' => services_api_key_auth_generate_key(),
      'user' => 'Aegir SaaS',
    ),
  );
  $endpoint->server_settings = array(
    'formatters' => array(
      'bencode' => TRUE,
      'json' => TRUE,
      'php' => TRUE,
      'xml' => TRUE,
      'jsonp' => FALSE,
    ),
    'parsers' => array(
      'application/json' => TRUE,
      'application/vnd.php.serialized' => TRUE,
      'application/x-www-form-urlencoded' => TRUE,
      'application/xml' => TRUE,
      'multipart/form-data' => TRUE,
      'text/xml' => TRUE,
    ),
  );
  $endpoint->resources = array(
    'hosting_site' => array(
      'alias' => 'site',
      'operations' => array(
        'retrieve' => array(
          'enabled' => '1',
        ),
        'index' => array(
          'enabled' => '1',
        ),
      ),
    ),
    'hosting_task' => array(
      'alias' => 'task',
      'operations' => array(
        'create' => array(
          'enabled' => '1',
        ),
      ),
    ),
  );
  $endpoint->debug = 0;

  // Add the single endpoint definition to the collection.
  $endpoints['hosting_saas'] = $endpoint;

  // Return the collection.
  return $endpoints;
}
