<?php

/**
 * Implementation of hook_menu().
 */
function hosting_saas_menu() {
  $items['admin/hosting/saas'] = array(
    'title' => 'SaaS',
    'description' => 'Configure software-as-a-service settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_saas_settings'),
    'access arguments' => array('administer modules'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Configuration form for hosting_saas
 */
function hosting_saas_settings() {
  $form['hosting_saas_master_domain'] = array(
    '#type' => 'textfield',
    '#title' => t('Master domain'),
    '#description' => t('The master domain for your SaaS sites. Accepted URLs will be *.thisfield'),
    '#default_value' => variable_get('hosting_saas_master_domain', 'localhost'),
    '#required' => TRUE,
  );

  $form['hosting_saas_template_site_nid'] = array(
    '#type' => 'textfield',
    '#title' => t('Template site'),
    '#description' => t('The nid of the site to clone on a new request. Optionnal if using an install-based method.'),
    '#default_value' => variable_get('hosting_saas_template_site_nid', ''),
  );

  $form['hosting_saas_db_server'] = array(
    '#type' => 'textfield',
    '#title' => t('Database server'),
    '#description' => t('The nid of the db server to use.'),
    '#default_value' => variable_get('hosting_saas_db_server', ''),
    '#required' => TRUE,
  );

  $form['hosting_saas_target_platform'] = array(
    '#type' => 'textfield',
    '#title' => t('Target platform'),
    '#description' => t('The nid of the platform on which to create the site when processing a request.'),
    '#default_value' => variable_get('hosting_saas_target_platform', ''),
    '#required' => TRUE,
  );

  $form['hosting_saas_max_capacity'] = array(
    '#type' => 'textfield',
    '#title' => t('Max Saas sites'),
    '#description' => t('The maximum number of SaaS sites allowed on the server. This will only count active sites.'),
    '#default_value' => variable_get('hosting_saas_max_capacity', '0'),
  );

  return system_settings_form($form);
}

function hosting_saas_settings_validate($form, &$form_state) {
  // TODO validate nids
}

/**
 * Implements hook_services_request_preprocess_alter().
 *
 * Add missing configuration to site clone requests.
 */
function hosting_saas_services_request_preprocess_alter($controller, &$args, $options) {
  if (($options['resource'] == 'task') &&
      ($controller['callback'] == 'hosting_services_save_task') &&
      ($args[1] == 'clone')) {

    // Ensure that we have a URL for the new site.
    if (empty($args[2]['new_uri'])) {
      watchdog('hosting_saas', "Cannot populate site clone task: 'options[new_uri]' not set in POST request's form data.", array(), WATCHDOG_ERROR);
      return;
    }

    // Set unset arguments so that we may reference them.
    if (empty($args[2]['new_db_server'])) {
      $args[2]['new_db_server'] = '';
    }
    if (empty($args[2]['target_platform'])) {
      $args[2]['target_platform'] = '';
    }

    // Get references to all of the arguments.
    $cloned_node_nid = &$args[0];
    $task_type = &$args[1];
    $new_uri = &$args[2]['new_uri'];
    $db_server_nid = &$args[2]['new_db_server'];
    $target_platform_nid = &$args[2]['target_platform'];

    // Set empty arguments as per the configuration.


  }
}

/**
 * Makes a site based on the settings.
 *
 * @param $url            The desired URL (FQDN)
 * @param $error_message  (Outgoing.) The error message that can be set on fail
 *
 * @return TRUE if successful, FALSE otherse. If this fails, the $error_message
 * will be set.
 */
function hosting_saas_clone_site_from_template($url, &$error_message = '') {
  $variables = array(
    'hosting_saas_target_platform',
    'hosting_saas_db_server',
    'hosting_saas_template_site_nid',
  );

  foreach ($variables as $to_check) {
    if (variable_get($to_check, NULL) === NULL) {
      watchdog('hosting_saas', "Variable hasn't been chosen yet: " . $to_check, array(), WATCHDOG_WARNING);
      
      $error_message = "Variable hasn't been chosen yet: " . $to_check;
      return FALSE;
    }
  }

  $model_site_nid = variable_get('hosting_saas_template_site_nid', NULL);

  // Bail out if there's already a queued clone task for our model site.
  // @todo Check if this is really necessary, as it now seems valid.
  if (hosting_saas_is_clone_ongoing($model_site_nid)) {
    $error_message = "A clone is already ongoing or queued.";
    return FALSE;
  }

  if (!hosting_domain_allowed($url)) { 
    $error_message = "This domain is not allowed. It is likely already being used.";
    return FALSE;
  }

  $args = array(
    'new_uri' => $url,
    'new_db_server' => variable_get('hosting_saas_db_server', NULL),
    'target_platform' => variable_get('hosting_saas_target_platform', NULL),
  );

  // Allow other modules to modify the options
  module_invoke_all('hosting_saas_clone', $url, $args);

  hosting_add_task($model_site_nid, 'clone', $args);

  return TRUE;
}

/**
 * Determine if the clone of a particular site is on-going.
 *
 * This tells us whether there's a clone task running or queued for the site.
 *
 * @param $site_nid
 *   The node ID of the site.
 * @return
 *   TRUE if clone is in progress, FALSE otherwise.
 * @todo
 *   Use an EntityFieldQuery instead of checking tables directly.
 */
function hosting_saas_is_clone_ongoing($site_nid) {
  $sql = "SELECT n.nid as nid, ht.rid, task_status, executed
          FROM hosting_task ht INNER JOIN node n
          ON ht.nid = n.nid AND ht.vid = n.vid
          WHERE ht.rid = %d AND ht.task_type = 'clone'
          AND (ht.task_status = -1 OR ht.task_status = 0)
          LIMIT 1";

  // If there's a result matching the above criteria, report confirmation.
  // Otherwise, there is no on-going clone.
  if (db_query($sql, $site_nid)->fetchObject()) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}
