<?php

/**
 * @file
 * This is the main module file for Aegir SaaS.
 *
 * It provides Drupal hooks and functions for the module.
 *
 * @todo Convert platform handling to distribution handling once
 * https://www.drupal.org/node/2704799 gets implemented.
 */

/**
 * Define the role created by the module.
 */
const HOSTING_SAAS_ROLE = "aegir web services";

/**
 * Define the user created by the module.
 */
const HOSTING_SAAS_USER = "Aegir SaaS";



/**
 * Implementation of hook_menu().
 */
function hosting_saas_menu() {
  $items['admin/hosting/saas'] = array(
    'title' => 'SaaS',
    'description' => 'Configure software-as-a-service settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_saas_settings'),
    'access arguments' => array('administer modules'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/hosting/saas/settings'] = array(
    'title' => 'Basic settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/hosting/saas/clients'] = array(
    'title' => 'Client handovers',
    'description' => 'Configure how site control is passed to clients',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_saas_settings_clients'),
    'access arguments' => array('administer sites'),
    'file' => 'hosting_saas.utils.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/hosting/saas/variables'] = array(
    'title' => 'Injected variables',
    'description' => 'Configure variables injected into client sites',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_saas_settings_variables'),
    'access arguments' => array('administer sites'),
    'file' => 'hosting_saas.utils.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * SaaS configuration form.
 */
function hosting_saas_settings() {
  $form['hosting_saas_master_domain'] = array(
    '#type' => 'textfield',
    '#title' => t('Master domain name'),
    '#description' => t('The master domain for your SaaS sites. Accepted URLs will be <em>*.thisfield</em>. If none is configured, all URLs will be accepted.'),
    '#default_value' => variable_get('hosting_saas_master_domain', 'localhost'),
  );

  $form['hosting_saas_template_site_nid'] = array(
    '#type' => 'textfield',
    '#title' => t('Template site URL'),
    '#description' => t('Enter the name of the site to clone on a new task clone request. This can either be set here, or provided in the remote request. If provided in the request, the value here will be overridden. Can be ignored if using an install-based method instead of the clone-based one provided by this module.'),
    '#autocomplete_path' => 'hosting/sites/autocomplete',
    '#default_value' => variable_get('hosting_saas_template_site_nid', ''),
  );

  $form['hosting_saas_db_server'] = array(
    '#type' => 'select',
    '#title' => t('Database server'),
    '#description' => t('The database server to use for new sites. This can either be set here, or provided in the remote request. If provided in the request, the value here will be overridden. Can be ignored if using an install-based method instead of the clone-based one provided by this module.'),
    '#options' => hosting_get_servers('db'),
    '#default_value' => variable_get('hosting_saas_db_server'),
  );

  $form['hosting_saas_target_platform'] = array(
    '#type' => 'textfield',
    '#title' => t('Target platform node ID'),
    '#description' => t('The node ID of the platform on which to create the site. This can either be set here, or provided in the remote request. If provided in the request, the value here will be overridden. Can be ignored if using an install-based method instead of the clone-based one provided by this module.'),
    '#default_value' => variable_get('hosting_saas_target_platform', ''),
  );

  $form['hosting_saas_max_capacity'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of sites'),
    '#description' => t('The maximum number of SaaS sites allowed on the server. This will only count active sites. For an unlimited number of sites, leave this value at zero.'),
    '#default_value' => variable_get('hosting_saas_max_capacity', '0'),
  );

  return system_settings_form($form);
}

/**
 * Validation for SaaS configuration form.
 */
function hosting_saas_settings_validate($form, &$form_state) {

  // Ensure that a site with the provided site name exists.
  if (!empty($form_state['values']['hosting_saas_template_site_nid'])) {
    if (!hosting_get_site_by_url($form_state['values']['hosting_saas_template_site_nid'], FALSE)) {
      form_set_error('hosting_saas_template_site_nid', t('Must be a valid site name.'));
    }
  }

  // Ensure that the DB server ID is actually a server.
  if (!empty($form_state['values']['hosting_saas_db_server'])) {
    $node = node_load($form_state['values']['hosting_saas_db_server']);
    if ((!is_object($node)) || ($node->type != 'server')) {
      form_set_error('hosting_saas_db_server', t('Must be a valid database server.'));
    }
  }

  // Ensure that the target platform ID is actually a platform.
  if (!empty($form_state['values']['hosting_saas_target_platform'])) {
    $node = node_load($form_state['values']['hosting_saas_target_platform']);
    if ((!is_object($node)) || ($node->type != 'platform')) {
      form_set_error('hosting_saas_target_platform', t('Must be a valid platform.'));
    }
  }

  // Ensure that the maximum number of sites is a non-negative integer.
  $number = $form_state['values']['hosting_saas_max_capacity'];
  if ((!ctype_digit($number)) || ($number < 0)) {
    form_set_error('hosting_saas_max_capacity', t('Must be a non-negative number.'));
  }
}

/**
 * Implements hook_services_request_preprocess_alter().
 *
 * Add missing configuration to site clone requests.
 */
function hosting_saas_services_request_preprocess_alter($controller, &$args, $options) {
  module_load_include('utils.inc', 'hosting_saas');

  if (($GLOBALS['user']->name == HOSTING_SAAS_USER) &&
      ($options['resource'] == 'task') &&
      ($controller['callback'] == 'hosting_services_save_task') &&
      ($args[1] == 'clone')) {

    hosting_saas_utils_bridge_variables($args[2]);

    // Ensure that we have a URL for the new site.
    if (empty($args[2]['new_uri'])) {
      watchdog('hosting_saas', "Cannot populate site clone task: URL of the new site was not specified. It must be provided in the POST form data as 'options[new_uri]'.", array(), WATCHDOG_ERROR);
      return;
    }

    // Set unset arguments so that we may reference them.
    if (empty($args[2]['new_db_server'])) {
      $args[2]['new_db_server'] = '';
    }
    if (empty($args[2]['target_platform'])) {
      $args[2]['target_platform'] = '';
    }

    // Get references to all of the alterable or otherwise useful arguments.
    $template_site = &$args[0];
    $new_uri = &$args[2]['new_uri'];
    $db_server_nid = &$args[2]['new_db_server'];
    $target_platform_nid = &$args[2]['target_platform'];

    // Ensure the new URL matches the configured domain.
    $domain = variable_get('hosting_saas_master_domain', 'localhost');
    if (!empty($domain) && (!hosting_saas_url_matches_domain($new_uri, $domain))) {
      $template_site = NULL;
      watchdog('hosting_saas', "Cannot populate site clone task: The requested URL '%url' does not match the configured domain '%domain'.", array(
        '%url' => $new_uri,
        '%domain' => $domain,
      ), WATCHDOG_ERROR);
      return;
    }

    // Ensure that the new URL is otherwise legal.
    if (!hosting_domain_allowed($new_uri)) {
      $template_site = NULL;
      watchdog('hosting_saas', "The new site URL %url is not allowed. It is likely already being used.", array(
        '%url' => $new_uri,
      ), WATCHDOG_ERROR);
      return;
    }

    // Set the ID of the site node to clone if it wasn't provided.
    if (empty($template_site)) {
      if (empty($template_site_saved = variable_get('hosting_saas_template_site_nid', ''))) {
        watchdog('hosting_saas', "Cannot populate site clone task: Template site name was not specified. Either save it in the settings, or provide it as 'nid' in the POST form data.", array(), WATCHDOG_ERROR);
        return;
      }
      $template_site = $template_site_saved;
    }

    // Convert the template site name to a node ID as that's what's required for
    // processing.
    $node_id = hosting_get_site_by_url($template_site, FALSE);
    if ($node_id !== FALSE) {
      $template_site = $node_id;
    }
    else {
      watchdog('hosting_saas', "Cannot populate site clone task: The provided template site name %template does not match an existing site.", array(
        '%template' => $template_site,
      ), WATCHDOG_ERROR);
      $template_site = NULL;
      return;
    }

    // Set the ID of the database server if it wasn't provided.
    if (empty($db_server_nid)) {
      if (empty($db_server_nid_saved = variable_get('hosting_saas_db_server', ''))) {
        watchdog('hosting_saas', "Cannot populate site clone task: Target DB server ID not specified. Either save it in the settings, or provide the server node ID as options[new_db_server] in the POST form data.", array(), WATCHDOG_ERROR);
        return;
      }
      $db_server_nid = $db_server_nid_saved;
    }

    // Set the ID of the platform if it wasn't provided.
    if (empty($target_platform_nid)) {
      if (empty($target_platform_nid_saved = variable_get('hosting_saas_target_platform', ''))) {
        watchdog('hosting_saas', "Cannot populate site clone task: Target platform ID not specified. Either save it in the settings, or provide the server node ID as options[target_platform] in the POST form data.", array(), WATCHDOG_ERROR);
        return;
      }
      $target_platform_nid = $target_platform_nid_saved;
    }

    // Ensure maximum capacity hasn't been reached.
    $capacity = variable_get('hosting_saas_max_capacity', '0');
    if (hosting_saas_at_full_capacity($target_platform_nid, $capacity) === TRUE) {
      // If it has, cause a failure and report it.
      $template_site = NULL;
      watchdog('hosting_saas', "Cannot fulfill site clone task: The maximum number of sites have already been provisioned through this service.", array(), WATCHDOG_ALERT);
      return;
    }
  }
}

// hook_node_insert
function hosting_saas_node_insert($node) {
  $bridged_values = variable_get('hosting_saas_utils_bridged_values', array());

  if ($node->type == 'site' && !empty($bridged_values[$node->title])) {
    hosting_variables_set_site_variables($node->nid, $bridged_values[$node->title]);

    // This variable is meant to be temporary
    unset($bridged_values[$node->title]);
    variable_set('hosting_saas_utils_bridged_values', $bridged_values);
  }
}

/**
 * Check to see if a given URL falls within a specific domain.
 *
 * @param $url
 *   The URL the check against the domain.
 * @param $domain
 *   The domain to compare with the URL.
 * @return
 *   TRUE if the URL is in the domain, FALSE otherwise.
 */
function hosting_saas_url_matches_domain($url, $domain) {
  // Prefix the URL with a dot.
  $dot_domain = '.' . $domain;

  // Get its length.
  $length = strlen($domain) + 1;

  // Compare it with the domain.
  if (substr_compare($url, $dot_domain, -$length, $length) === 0) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Check to see if we're at the maximum number of sites allowed.
 *
 * @param $platform
 *   The platform whose capacity is to be checked.
 * @param $capacity
 *   The total number of sites allowed on the system.
 * @return
 *   TRUE if we're at capacity, FALSE otherwise.
 */
function hosting_saas_at_full_capacity($platform, $capacity) {

  // If there's no limit, we can never be at capacity.
  if (intval($capacity) <= 0) {
    return FALSE;
  }

  // Fetch the number of sites on the platform.
  $count = hosting_site_count($platform);

  // If the number of sites has reached the limit, report a problem.
  if ($count >= $capacity) {
    return TRUE;
  }

  // Otherwise, everything is fine. Leave the flag down with log entry.
  watchdog('hosting_saas', 'Site count / capacity: %count / %capacity', array(
    '%count' => $count,
    '%capacity' => $capacity,
  ));
  return FALSE;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function hosting_saas_ctools_plugin_api($owner, $api) {
  // Ensure that we'll be able to register our Services endpoint.
  if (($owner == 'services') && ($api == 'services')) {
    return array(
      'version' => 3,
    );
  }
}

/**
 * Implements hook_default_services_endpoint().
 *
 * Register our Services endpoint.
 */
function hosting_saas_default_services_endpoint() {

  // This is the configuration for our endpoint. It differs from a UI export
  // in that we're generating a pseudo-random API key through a function call.
  $endpoint = new stdClass();
  $endpoint->disabled = FALSE; /* Edit this to true to make a default endpoint disabled initially */
  $endpoint->api_version = 3;
  $endpoint->name = 'hosting_saas';
  $endpoint->server = 'rest_server';
  $endpoint->path = 'aegir/saas';
  $endpoint->authentication = array(
    'services_api_key_auth' => array(
      // The API key being defined here will actually change every time the
      // configuration is loaded. This is a security feature to prevent a fixed
      // or empty one from being used for unauthorized remote access. To
      // generate a stable one that can be used for legitimate access
      // consistently, an administrator must manually save the authentication
      // form to override these default settings.
      'api_key' => services_api_key_auth_generate_key(),
      'user' => 'Aegir SaaS',
    ),
  );
  $endpoint->server_settings = array(
    'formatters' => array(
      'bencode' => TRUE,
      'json' => TRUE,
      'php' => TRUE,
      'xml' => TRUE,
      'jsonp' => FALSE,
    ),
    'parsers' => array(
      'application/json' => TRUE,
      'application/vnd.php.serialized' => TRUE,
      'application/x-www-form-urlencoded' => TRUE,
      'application/xml' => TRUE,
      'multipart/form-data' => TRUE,
      'text/xml' => TRUE,
    ),
  );
  $endpoint->resources = array(
    'hosting_site' => array(
      'alias' => 'site',
      'operations' => array(
        'retrieve' => array(
          'enabled' => '1',
        ),
        'index' => array(
          'enabled' => '1',
        ),
      ),
    ),
    'hosting_task' => array(
      'alias' => 'task',
      'operations' => array(
        'create' => array(
          'enabled' => '1',
        ),
      ),
    ),
  );
  $endpoint->debug = 0;

  // Add the single endpoint definition to the collection.
  $endpoints['hosting_saas'] = $endpoint;

  // Return the collection.
  return $endpoints;
}

/**
 * Implements hook_post_hosting_TASK_TYPE_task().
 */
function hosting_saas_post_hosting_verify_task($task, $data) {
  // TODO: Option to unset the settings configuration post-verify
  // (so the user can change them).

  drush_log(t('[hosting_saas] TEST'));

  $site = node_load($task->rid);

  if (!empty($site)) {
    $target = $site->hosting_name;
    $todo = variable_get('hosting_saas_todo', array());

    drush_log(t('[hosting_saas] TEST2'));

    if (!empty($todo[$site->hosting_name])) {
      drush_log(t('[hosting_saas] TEST3'));
      $client_user = $todo[$site->hosting_name]['create_new_user'];

      if (!empty($client_user)) {
        drush_log(t('[hosting_saas] Creating new user: !name (!email).', array('!name' => $client_user['name'], '!email' => $client_user['email'])));

        $results['user-create'] = provision_backend_invoke($target, 'user-create "' . $client_user['name'] . '" --mail="' . $client_user['email'] . '"');
      }
      else {
        $client_user =  $todo[$site->hosting_name]['change_admin_user'];

        if (!empty($client_user)) {
          //drush_log(t('[hosting_saas] Assigning new values to admin user: !name (!email).', array('!name' => $client_user['name'], '!email' => $client_user['email'])));
          // TODO
        }
      }

      if (!empty($todo[$site->hosting_name]['set_user_role'])) {
        drush_log(t('[hosting_saas] Assigning role: !role', array('!role' => $todo[$site->hosting_name]['set_user_role'])));
        $results['user-assign-role'] = provision_backend_invoke($target, "user-add-role '" . $todo[$site->hosting_name]['set_user_role'] . "' --mail='" . $client_user['email'] . "'");
      }

      //   send_email
      if ($todo[$site->hosting_name]['send_email']) {
        // Clumsily parse uid and send notification until Drush implements --notify
        $user_info = provision_backend_invoke($target, 'user-information --full "' . $client_user['email'] . '"');

        if (preg_match ('/User ID.* ([0-9]+)/', $user_info['output'], $matches)) {
          $new_user_uid = $matches[1];
        }
        else {
          drush_set_error(t('[hosting_saas_utils] Could not parse user ID of new user! User creation failed?'));
        }

        drush_log('[hosting_saas_utils] Parsed uid of new user of new site: ' . $new_user_uid);

        $message = "status_activated";
        $result ['notify'] = provision_backend_invoke($target, "eval  '_user_mail_notify(\"".$message."\", user_load($new_user_uid));'");

        drush_log(t("[hosting_saas_utils] Sent registration email to !name",  array('!name' => $client_user['name'])));
      }

      unset($todo[$site->hosting_name]);
      variable_set('hosting_saas_utils_todo', $todo);
    }
  }
}
